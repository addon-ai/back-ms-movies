package {{packageName}};

import {{domain_ports_input}}.{{entityName}}UseCase;
import {{domain_ports_output}}.{{entityName}}RepositoryPort;
{{#hasCreate}}import {{application_dto}}.{{serviceName}}.Create{{entityName}}RequestContent;{{/hasCreate}}
{{#hasCreate}}import {{application_dto}}.{{serviceName}}.Create{{entityName}}ResponseContent;{{/hasCreate}}
{{#hasGet}}import {{application_dto}}.{{serviceName}}.Get{{entityName}}ResponseContent;{{/hasGet}}
{{#hasUpdate}}import {{application_dto}}.{{serviceName}}.Update{{entityName}}RequestContent;{{/hasUpdate}}
{{#hasUpdate}}import {{application_dto}}.{{serviceName}}.Update{{entityName}}ResponseContent;{{/hasUpdate}}
{{#hasDelete}}import {{application_dto}}.{{serviceName}}.Delete{{entityName}}ResponseContent;{{/hasDelete}}
{{#hasList}}import {{application_dto}}.{{serviceName}}.List{{entityName}}sResponseContent;{{/hasList}}
{{#hasComplexOperations}}
{{#complexOperations}}
import {{application_dto}}.{{serviceName}}.{{responseType}};
{{/complexOperations}}
{{/hasComplexOperations}}
import {{domain_model}}.{{entityName}};
import {{application_mapper}}.{{entityName}}Mapper;
import {{infra_config_exceptions}}.NotFoundException;
import {{utils}}.LoggingUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;

/**
 * Consolidated application service implementing all {{entityName}} use cases.
 * 
 * @author {{author}}
 * @version {{version}}
 */
@Service
@RequiredArgsConstructor
public class {{entityName}}Service implements {{entityName}}UseCase {

    private static final LoggingUtils logger = LoggingUtils.getLogger({{entityName}}Service.class);
    
    private final {{entityName}}RepositoryPort {{entityVarName}}RepositoryPort;
    private final {{entityName}}Mapper {{entityVarName}}Mapper;

{{#hasCreate}}
    @Override
    public Mono<Create{{entityName}}ResponseContent> create(Create{{entityName}}RequestContent request) {
        logger.info("Executing Create{{entityName}} with request: {}", request);
        
        return Mono.fromCallable(() -> {{entityVarName}}Mapper.fromCreateRequest(request))
                .flatMap({{entityVarName}}RepositoryPort::save)
                .map(saved{{entityName}} -> {
                    logger.info("{{entityName}} created successfully with ID: {}", saved{{entityName}}.get{{entityName}}Id());
                    return {{entityVarName}}Mapper.toCreateResponse(saved{{entityName}});
                })
                .doOnError(e -> logger.error("Error in Create{{entityName}}", e, request));
    }
{{/hasCreate}}

{{#hasGet}}
    @Override
    public Mono<Get{{entityName}}ResponseContent> get(String {{entityVarName}}Id) {
        logger.info("Executing Get{{entityName}} with {{entityVarName}}Id: {}", {{entityVarName}}Id);
        
        return {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .switchIfEmpty(Mono.error(new NotFoundException("{{entityName}} not found")))
                .map({{entityVarName}} -> {
                    logger.info("{{entityName}} retrieved successfully with ID: {}", {{entityVarName}}Id);
                    return {{entityVarName}}Mapper.toGetResponse({{entityVarName}});
                })
                .doOnError(e -> logger.error("Error in Get{{entityName}}", e, {{entityVarName}}Id));
    }
{{/hasGet}}

{{#hasUpdate}}
    @Override
    public Mono<Update{{entityName}}ResponseContent> update(String {{entityVarName}}Id, Update{{entityName}}RequestContent request) {
        logger.info("Executing Update{{entityName}} with {{entityVarName}}Id: {} and request: {}", {{entityVarName}}Id, request);
        
        return {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .switchIfEmpty(Mono.error(new NotFoundException("{{entityName}} not found")))
                .map(existing{{entityName}} -> {
                    {{entityVarName}}Mapper.updateEntityFromRequest(request, existing{{entityName}});
                    existing{{entityName}}.setUpdatedAt(java.time.Instant.now().toString());
                    return existing{{entityName}};
                })
                .flatMap({{entityVarName}}RepositoryPort::save)
                .map(saved{{entityName}} -> {
                    logger.info("{{entityName}} updated successfully with ID: {}", {{entityVarName}}Id);
                    return {{entityVarName}}Mapper.toUpdateResponse(saved{{entityName}});
                })
                .doOnError(e -> logger.error("Error in Update{{entityName}}", e, {{entityVarName}}Id));
    }
{{/hasUpdate}}

{{#hasDelete}}
    @Override
    public Mono<Delete{{entityName}}ResponseContent> delete(String {{entityVarName}}Id) {
        logger.info("Executing Delete{{entityName}} with {{entityVarName}}Id: {}", {{entityVarName}}Id);
        
        return {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .switchIfEmpty(Mono.error(new NotFoundException("{{entityName}} not found")))
                .flatMap({{entityVarName}} -> {{entityVarName}}RepositoryPort.deleteById({{entityVarName}}Id))
                .then(Mono.fromCallable(() -> {
                    logger.info("{{entityName}} deleted successfully with ID: {}", {{entityVarName}}Id);
                    return Delete{{entityName}}ResponseContent.builder()
                            .deleted(true)
                            .message("{{entityName}} deleted successfully")
                            .build();
                }))
                .doOnError(e -> logger.error("Error in Delete{{entityName}}", e, {{entityVarName}}Id));
    }
{{/hasDelete}}

{{#hasList}}
    @Override
    public Mono<List{{entityName}}sResponseContent> list(Integer page, Integer size, String search, String status, String dateFrom, String dateTo) {
        // Apply default values
        String effectiveStatus = (status == null || status.trim().isEmpty()) ? "ACTIVE" : status;
        String effectiveDateFrom = (dateFrom == null || dateFrom.trim().isEmpty()) ? 
            java.time.Instant.now().minus(30, java.time.temporal.ChronoUnit.DAYS).toString() : dateFrom;
        String effectiveDateTo = (dateTo == null || dateTo.trim().isEmpty()) ? 
            java.time.Instant.now().toString() : dateTo;
        
        logger.info("Executing List{{entityName}}s with page: {}, size: {}, search: {}, status: {} (effective: {}), dateFrom: {} (effective: {}), dateTo: {} (effective: {})", 
                   page, size, search, status, effectiveStatus, dateFrom, effectiveDateFrom, dateTo, effectiveDateTo);
        
        return {{entityVarName}}RepositoryPort.findByFilters(search, effectiveStatus, effectiveDateFrom, effectiveDateTo, page, size)
                .collectList()
                .map({{entityVarName}}s -> {
                    logger.info("Retrieved {} {{entityVarName}}s successfully", {{entityVarName}}s.size());
                    int pageNum = page != null ? page : 1;
                    int pageSize = size != null ? size : 20;
                    return {{entityVarName}}Mapper.toListResponse({{entityVarName}}s, pageNum, pageSize);
                })
                .doOnError(e -> logger.error("Error in List{{entityName}}s", e));
    }
{{/hasList}}

{{#hasComplexOperations}}
{{#complexOperations}}
    @Override
    public Mono<{{responseType}}> {{methodName}}() {
        logger.info("Executing {{operationId}}");
        
        return {{entityVarName}}RepositoryPort.{{repositoryMethod}}({{defaultParameter}})
                .collectList()
                .map({{entityVarName}}s -> {
                    logger.info("Retrieved {} {{entityVarName}}s successfully", {{entityVarName}}s.size());
                    return {{responseType}}.builder().build();
                })
                .doOnError(e -> logger.error("Error in {{operationId}}", e));
    }

{{/complexOperations}}
{{/hasComplexOperations}}
}