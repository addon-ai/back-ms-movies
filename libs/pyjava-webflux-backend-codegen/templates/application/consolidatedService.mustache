package {{packageName}};

import {{domain_ports_input}}.{{entityName}}UseCase;
import {{domain_ports_output}}.{{entityName}}RepositoryPort;
{{#hasCreate}}import {{application_dto}}.{{serviceName}}.Create{{entityName}}RequestContent;{{/hasCreate}}
{{#hasCreate}}import {{application_dto}}.{{serviceName}}.Create{{entityName}}ResponseContent;{{/hasCreate}}
{{#hasGet}}import {{application_dto}}.{{serviceName}}.Get{{entityName}}ResponseContent;{{/hasGet}}
{{#hasUpdate}}import {{application_dto}}.{{serviceName}}.Update{{entityName}}RequestContent;{{/hasUpdate}}
{{#hasUpdate}}import {{application_dto}}.{{serviceName}}.Update{{entityName}}ResponseContent;{{/hasUpdate}}
{{#hasDelete}}import {{application_dto}}.{{serviceName}}.Delete{{entityName}}ResponseContent;{{/hasDelete}}
{{#hasList}}import {{application_dto}}.{{serviceName}}.List{{entityName}}sResponseContent;{{/hasList}}
{{#hasComplexOperations}}
{{#complexOperations}}
import {{application_dto}}.{{serviceName}}.{{responseType}};
{{/complexOperations}}
{{/hasComplexOperations}}
import {{domain_model}}.{{entityName}};
import {{application_mapper}}.{{entityName}}Mapper;
import {{infra_config_exceptions}}.NotFoundException;
import {{utils}}.LoggingUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;

/**
 * Consolidated application service implementing all {{entityName}} use cases.
 * 
 * @author {{author}}
 * @version {{version}}
 */
@Service
@RequiredArgsConstructor
public class {{entityName}}Service implements {{entityName}}UseCase {

    private static final LoggingUtils logger = LoggingUtils.getLogger({{entityName}}Service.class);
    
    private final {{entityName}}RepositoryPort {{entityVarName}}RepositoryPort;
    private final {{entityName}}Mapper {{entityVarName}}Mapper;

{{#hasCreate}}
    @Override
    public Mono<Create{{entityName}}ResponseContent> create(Create{{entityName}}RequestContent request) {
        logger.info("Executing Create{{entityName}} with request: {}", request);
        
        return Mono.fromCallable(() -> {{entityVarName}}Mapper.fromCreateRequest(request))
                .flatMap({{entityVarName}}RepositoryPort::save)
                .map(saved{{entityName}} -> {
                    logger.info("{{entityName}} created successfully with ID: {}", saved{{entityName}}.get{{entityName}}Id());
                    return {{entityVarName}}Mapper.toCreateResponse(saved{{entityName}});
                })
                .doOnError(e -> logger.error("Error in Create{{entityName}}", e, request));
    }
{{/hasCreate}}

{{#hasGet}}
    @Override
    public Mono<Get{{entityName}}ResponseContent> get(String {{entityVarName}}Id) {
        logger.info("Executing Get{{entityName}} with {{entityVarName}}Id: {}", {{entityVarName}}Id);
        
        return {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .switchIfEmpty(Mono.error(new NotFoundException("{{entityName}} not found")))
                .map({{entityVarName}} -> {
                    logger.info("{{entityName}} retrieved successfully with ID: {}", {{entityVarName}}Id);
                    return {{entityVarName}}Mapper.toGetResponse({{entityVarName}});
                })
                .doOnError(e -> logger.error("Error in Get{{entityName}}", e, {{entityVarName}}Id));
    }
{{/hasGet}}

{{#hasUpdate}}
    @Override
    public Mono<Update{{entityName}}ResponseContent> update(String {{entityVarName}}Id, Update{{entityName}}RequestContent request) {
        logger.info("Executing Update{{entityName}} with {{entityVarName}}Id: {} and request: {}", {{entityVarName}}Id, request);
        
        return {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .switchIfEmpty(Mono.error(new NotFoundException("{{entityName}} not found")))
                .map(existing{{entityName}} -> {
                    {{entityVarName}}Mapper.updateEntityFromRequest(request, existing{{entityName}});
                    existing{{entityName}}.setUpdatedAt(java.time.Instant.now().toString());
                    return existing{{entityName}};
                })
                .flatMap({{entityVarName}}RepositoryPort::save)
                .map(saved{{entityName}} -> {
                    logger.info("{{entityName}} updated successfully with ID: {}", {{entityVarName}}Id);
                    return {{entityVarName}}Mapper.toUpdateResponse(saved{{entityName}});
                })
                .doOnError(e -> logger.error("Error in Update{{entityName}}", e, {{entityVarName}}Id));
    }
{{/hasUpdate}}

{{#hasDelete}}
    @Override
    public Mono<Delete{{entityName}}ResponseContent> delete(String {{entityVarName}}Id) {
        logger.info("Executing Delete{{entityName}} with {{entityVarName}}Id: {}", {{entityVarName}}Id);
        
        return {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .switchIfEmpty(Mono.error(new NotFoundException("{{entityName}} not found")))
                .flatMap({{entityVarName}} -> {{entityVarName}}RepositoryPort.deleteById({{entityVarName}}Id))
                .then(Mono.fromCallable(() -> {
                    logger.info("{{entityName}} deleted successfully with ID: {}", {{entityVarName}}Id);
                    return Delete{{entityName}}ResponseContent.builder()
                            .deleted(true)
                            .message("{{entityName}} deleted successfully")
                            .build();
                }))
                .doOnError(e -> logger.error("Error in Delete{{entityName}}", e, {{entityVarName}}Id));
    }
{{/hasDelete}}

{{#hasList}}
    @Override
    public Mono<List{{entityName}}sResponseContent> list(Integer page, Integer size, String search) {
        logger.info("Executing List{{entityName}}s with page: {}, size: {}, search: {}", page, size, search);
        
        Flux<{{entityName}}> {{entityVarName}}Flux;
        if (search != null && !search.trim().isEmpty()) {
            {{entityVarName}}Flux = {{entityVarName}}RepositoryPort.findBySearchTerm(search, page, size);
        } else {
            {{entityVarName}}Flux = {{entityVarName}}RepositoryPort.findAll();
        }
        
        return {{entityVarName}}Flux
                .collectList()
                .map({{entityVarName}}s -> {
                    logger.info("Retrieved {} {{entityVarName}}s successfully", {{entityVarName}}s.size());
                    return {{entityVarName}}Mapper.toListResponse({{entityVarName}}s, page != null ? page : 1, size != null ? size : 20);
                })
                .doOnError(e -> logger.error("Error in List{{entityName}}s", e));
    }
{{/hasList}}

{{#hasComplexOperations}}
{{#complexOperations}}
    @Override
    public {{responseType}} {{methodName}}() {
        logger.info("Executing {{operationId}}");
        
        try {
            // TODO: Implement {{operationId}} business logic
            logger.info("{{operationId}} executed successfully");
            throw new UnsupportedOperationException("{{operationId}} not yet implemented");
        } catch (Exception e) {
            logger.error("Error in {{operationId}}", e);
            throw e;
        }
    }

{{/complexOperations}}
{{/hasComplexOperations}}
}